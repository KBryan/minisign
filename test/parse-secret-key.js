var test = require('tape')
var minisign = require('../minisign')
var fs = require('fs')
var sodium = require('sodium-native')

test('parse minisign generated key file', (t) => {
  const untrustedComment = 'minisign encrypted secret key'

  fs.readFile('./test/fixtures/no-string.key', (err, data) => {
    t.error(err)
    var SKinfo = minisign.parseSecretKey(data)
    var endData = Buffer.from(data.subarray(-105, -1).toString(), 'base64')

    t.equal(SKinfo.untrustedComment, untrustedComment)
    t.equal(SKinfo.signatureAlgorithm.toString(), 'Ed')
    t.equal(SKinfo.kdfAlgorithm.toString(), 'Sc')
    t.equal(SKinfo.cksumAlgorithm.toString(), 'B2')
    t.equal(SKinfo.kdfSalt.length, sodium.crypto_pwhash_scryptsalsa208sha256_SALTBYTES)
    t.equal(SKinfo.kdfOpsLimit, sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE)
    t.equal(SKinfo.kdfMemLimit, sodium.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE)
    t.equal(SKinfo.keynumSK.length, 104)
    t.equal(SKinfo.keynumSK.slice(-1)[0], endData.slice(-2)[1])
    t.end()
  })
})

test('parse key pair generated by minisign.js', (t) => {
  const untrustedComment = 'minisign encrypted secret key'

  var emptyBuf = Buffer.from('')
  var pwd = sodium.sodium_malloc(emptyBuf.byteLength)
  pwd.fill(emptyBuf)

  const keyGen = minisign.keypairGen(pwd)
  const keyPair = minisign.formatKeys(keyGen)
  const keyInfo = keyPair.SK

  var SKinfo = minisign.parseSecretKey(keyInfo)
  var endData = Buffer.from(keyInfo.subarray(-105, -1).toString(), 'base64')

  t.equal(SKinfo.untrustedComment, untrustedComment)
  t.equal(SKinfo.signatureAlgorithm.toString(), 'Ed')
  t.equal(SKinfo.kdfAlgorithm.toString(), 'Sc')
  t.equal(SKinfo.cksumAlgorithm.toString(), 'B2')
  t.equal(SKinfo.kdfSalt.length, sodium.crypto_pwhash_scryptsalsa208sha256_SALTBYTES)
  t.equal(SKinfo.kdfOpsLimit, sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE)
  t.equal(SKinfo.kdfMemLimit, sodium.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE)
  t.equal(SKinfo.keynumSK.length, 104)
  t.equal(SKinfo.keynumSK.slice(-1)[0], endData.slice(-2)[1])
  t.end()
})

test('comment removed from minisign file', (t) => {
  fs.readFile('./test/fixtures/missing-comment.key', (err, data) => {
    t.error(err)
    t.throws(() => minisign.parseSecretKey(data), 'file format not recognised')
    t.end()
  })
})

test('line breaks within key', (t) => {
  fs.readFile('./test/fixtures/line-break-start.key', (err, data) => {
    t.error(err)
    t.throws(() => minisign.parseSecretKey(data), 'file format not recognised')
    t.end()
  })
})

test('line break at the end of key', (t) => {
  fs.readFile('./test/fixtures/line-break-end.key', (err, data) => {
    t.error(err)
    t.throws(() => minisign.parseSecretKey(data), 'file format not recognised')
    t.end()
  })
})

test('missing line break after comment', (t) => {
  fs.readFile('./test/fixtures/missing-line-break.key', (err, data) => {
    t.error(err)
    t.throws(() => minisign.parseSecretKey(data), 'file format not recognised')
    t.end()
  })
})

test('missing characters in secret key info', (t) => {
  fs.readFile('./test/fixtures/missing-characters.key', (err, data) => {
    t.error(err)
    t.throws(() => minisign.parseSecretKey(data), 'base64 conversion failed, was an actual secret key given?')
    t.end()
  })
})
